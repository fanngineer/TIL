# Tree
## Tree
- 비선형 구조
- 원소들 간에 1:N 관계의 자료구조
- 원소들 간 계층관계를 가지는 계층형 자료구조
- 상위 원소에서 하위원소로 내려가면서 확장되는 나무 모양의 구조
- 한 개 이상의 노드로 이루어진 유한 집합이며 다음 조건을 만족한다.
  - 노드 중 최상위 노드를 루트(Root)라 한다.
  - T1,...,TN은 각각 하나의 트리가 되며 루트의 subtree라 한다.
## Tree 용어
- 노드 : 트리의 원소
- Edge : 노드를 연결하는 선
- 조상 노드 : 간선을 따라 루트 노드까지 경로에 있는 모든 노드들
- 차수 : 노드에 연결된 자식 노드의 수
- 트리의 차수 : 트리에 있는 노드의 차수 중에서 가장 큰 값
- 단말 노드 : 차수가 0인 노드, 마지막에 위치한 노드
- 높이 : 루트에서 노드에 이르는 간선의 수. 노드의 레벨
- 트리의 높이 : 트리에 있는 노드 높이 중 가장 큰 값

## 이진 트리
- 모든 노드들이 2개의 서브 트리를 갖는 특별한 형태의 트리
- 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리
- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수는 h+1개, 최대 개수는 2<sup>h+1</sup>-1개가 된다.
- Full Binary Tree
  - 모든 모든 레벨에 노드가 포화상태로 차 있는 이진 트리
  - 높이가 h일 때, 노드 개수 2<sup>h+1</sup>-1의 노드를 가진 이진 트리
  - 루트를 1 번으로, 2<sup>h+1</sup>-1까지 정해진 위치에 대한 노드 번호를 가진다.
- Complete Binary Tree
  - 높이가 h이고 노드 수가 n개 일때, 포화 이진 트리의 노드 번호 1번부터 n번까지 빈 자리가 없는 이진 트리
- Skewed Binary Tree
  - 높이 h에 대한 최소 노드 개수를 가지며, 한쪽 방향의 자식 노드 만을 가진 이진 트리
## 순회(Traversal)
- 순회란 각 노드를 중복되지 않게 전부 방문하는 것. 트리는 비 선형 구조이므로 선후 연결 관계를 알 수 없다.
- 트리의 순회 방법
  - 전위 순회(Preorder traversal) : VLR
    ```
    preorder_traverse(T){
      if(T is not null){
          visit(T)
          preorder_traverse(T.left)
          preorder_traverse(T.right)
      }
    }
    ```
  - 중위 순회(Inorder traversal) : LVR
    ```
    inorder_traverse(T){
      if(T is not null){
          inorder_traverse(T.left)
          visit(T)
          inorder_traverse(T.right)
      }
    }
    ```
  - 후위 순회(Postorder traversal) : LRV
    ```
    postorder_traverse(T){
      if(T is not null){
          postorder_traverse(T.left)
          postorder_traverse(T.right)
          visit(T)
      }
    }
    ```
## 이진트리의 표현
- 배열을 이용한 표현 : 루트를 1로 번호를 부여해서 레벨 n에 대해 왼쪽 부터 오른쪽으로 2<sup>n</sup>부터 2<sup>n+1</sup>-1까지 번호 부여
  - 노드 번호의 성질
    - 노드 번호가  i인 노드의 부모 노드 번호 : i/2
    - 노드 번호 i의 자식 노드 번호 : i*2, i*2+1
    - 레벨 2의 노드 번호 시작 번호 : 2<sup>n</sup>
    - 노드 번호를 배열의 인덱스로 사용
- 배열을 이용한 표현은 메모리 낭비가 발생하기 때문에 연결리스트를 사용하여 표현 가능

## 수식 트리
- 수식을 표현하는 이진 트리
- 연산자는 루트 노드 혹은 가지 노드
- 피연산자는 모두 잎 노드

## 힙
- 완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 가장 작은 노드를 찾기 위해서 만든 자료구조
- 최대 힙
  - 키 값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - 부모 노드의 키 값 > 자식 노드의 키 값
  - 루트 노드가 가장 큰 키 값을 가진다.
- 최소 힙
  - 키 값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - 부모 노드의 키 값 < 자식 노드의 키 값
  - 루트 노드가 가장 작은 키 값을 가진다.
- 삽입
  - 삽입할 자리 확장
  - 확장한 자리에 삽입할 원소 저장
  - 부모 노드와 순서에 맞게 자리 바꾸기 반복
  - 비교할 부모 노드가 없으면 자리 확정
- 삭제
  - 힙에서는 루트 노드의 원소만을 삭제 할 수 있다.
  - 루트 노드의 원소를 삭제하여 반환한다.
  - 힙의 종류에 따라 최대, 최소값을 구할 수 있다.
  - 삭제 예
    - 루트 노드의 원소 삭제
    - 마지막 노드 삭제
    - 자리바꾸기
    - 자리 확정
## 우선순위 큐
- 우선순위 큐를 구현하는 가장 효율적인 방법이 힙을 사용하는 것
  - 노드 추가/ 삭제의 시간 복잡도가 O(logN)이고, 최댓값/최솟값을 O(1)에 구할 수 있음
  - 완전 정렬보다 관리 비용이 적다.
- 배열을 통해 트리 형태를 쉽게 구현할 수 있다.
- java.util.PriorityQueue

## 힙 정렬
- 이진 트리와 유사한 방법으로 수행
- 하나의 값을 삽입(반복) >> 힙에서 순차적으로 값을 하나씩 제거
- 전체 정렬의 시간 복잡도 O(NlogN)
- 힙 정렬은 배열에 저장된 자료를 정렬하기에 
 
